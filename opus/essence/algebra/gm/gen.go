package gm

import (
	"errors"
	"fmt"
	"github.com/brianvoe/gofakeit/v6"
	"github.com/widmogrod/software-architecture-playground/opus/essence/algebra/kv"
	"io"
	"math/rand"
	"reflect"
	"strings"
	"text/template"
)

func GenerateRandomData(r *SchemaRegistry, id string, in interface{}) error {
	// get schema
	sch, err := r.Get(id)
	if err != nil {
		return err
	}

	// reflect in
	v := reflect.ValueOf(in)
	// if ptr to struct
	if v.Kind() == reflect.Ptr {
		v = v.Elem()
	}

	if v.Kind() == reflect.Struct {
		// iterate over fields
		for i := 0; i < v.NumField(); i++ {
			// check if field is required
			field := v.Type().Field(i)
			attr, _, err := extractAttr(field, sch)
			if err != nil {
				return err
			}

			// randomly skip non required field
			if !attr.Required && rand.Intn(2) == 0 {
				continue
			}

			// field pointer
			fieldPtr := v.Field(i)

			// set field value depening of its type
			fieldPtr.Set(generateValueOfForType(attr))
		}

		return nil
	}

	if v.Kind() == reflect.Map {
		// iterate over attribute names
		for fieldName, attr := range sch.Attrs {
			// randomly skip non required field
			if !attr.Required && rand.Intn(2) == 0 {
				continue
			}
			v.SetMapIndex(reflect.ValueOf(fieldName), generateValueOfForType(&attr))
		}

		return nil
	}

	return errors.New("not implemented for this type: " + v.Kind().String())
}

func extractAttr(field reflect.StructField, sch *Schema) (*AttrType, *string, error) {
	// get field from schema
	fieldName := field.Name
	attr, ok := sch.Attrs[fieldName]
	if !ok {
		// field name from tag name
		fieldName = field.Tag.Get("name")
		attr, ok = sch.Attrs[fieldName]
		if !ok {
			return nil, nil, errors.New("field " + fieldName + " is not defined in schema")
		}
	}

	return &attr, &fieldName, nil
}

func generateValueOfForType(v *AttrType) reflect.Value {
	switch v.T {
	case StringType:
		//return reflect.ValueOf(gofakeit.Word())
		return reflect.ValueOf(kv.PtrString(gofakeit.Word()))
	case IntType:
		return reflect.ValueOf(kv.PtrInt64(gofakeit.Int64()))
		//return reflect.ValueOf(gofakeit.Int64())
	case BoolType:
		//return reflect.ValueOf(gofakeit.Bool())
		return reflect.ValueOf(kv.PtrBool(gofakeit.Bool()))
	default:
		panic(fmt.Sprintf("not implemented for this type=%v", v))
	}
}

// create new golang template
var goStruct = `
type {{fieldName .Name}} struct {
{{- range $k, $type := .Attrs }}
	{{fieldName $k}} *{{typeName $type.T}} {{tag}}name:"{{$k}}"{{tag}}
{{- end }}
}
`

// create new golang template
var defaultStruct = `
func Default{{fieldName .Name}}() *{{fieldName .Name}} {
	return &{{fieldName .Name}} {
	{{- range $k, $type := .Attrs }}
		{{- if not (eq $type.Default nil) -}}
		{{- if isString $type }}
		{{fieldName $k}}: kv.PtrString("{{ $type.Default }}"),
		{{- end -}}
		{{- if isInt $type }}
		{{fieldName $k}}: kv.PtrInt64({{ $type.Default }}),
		{{- end -}}
		{{- if isBool $type }}
		{{fieldName $k}}: kv.PtrBool({{ $type.Default }}),
		{{- end -}}
		{{- if isTime $type }}	
		{{fieldName $k}}: kv.PtrTime(time.Now()),
		{{- end -}}
		{{- end -}}
	{{- end }}
	}
}
`

// create new golang template
var toAttributes = `
func (self *{{fieldName .Name}}) ToAttr() map[string]kv.AttrType {
	return map[string]kv.AttrType{
{{- range $k, $type := .Attrs }}
		"{{$k}}": {
			{{- if isString $type -}}
			S: self.{{fieldName $k}}
			{{- end -}}
			{{- if isInt $type -}}
			I: self.{{fieldName $k}}
			{{- end -}}
			{{- if isBool $type -}}
			B: self.{{fieldName $k}}
			{{- end -}}
			{{- if isTime $type -}}	
			DT: self.{{fieldName $k}}
			{{- end -}}
		},
{{- end }}
	}
}
`

var toKey = `
func (self *{{fieldName .Name}}) ToKey() kv.Key {
	return kv.Key{
		PartitionKey: *self.{{ fieldName (findIdKey .Attrs) }},
		EntityKey: "{{ .Name }}",
	}
}
`

var toSchemaId = `
func (self *{{fieldName .Name}}) SchemaID() string {
	return "{{ .Name }}"
}
`

type GenConf struct {
	PackageName string
}

func GenerateGolangCode(r *SchemaRegistry, id string, res io.Writer, conf *GenConf) error {
	// get schema
	sch, err := r.Get(id)
	if err != nil {
		return err
	}

	funMap := template.FuncMap{
		"typeName":  TypeToString,
		"fieldName": strings.Title,
		"tag": func() string {
			return "`"
		},
		"isString": func(v AttrType) bool {
			return v.T == StringType
		},
		"isInt": func(v AttrType) bool {
			return v.T == IntType
		},
		"isBool": func(v AttrType) bool {
			return v.T == BoolType
		},
		"isTime": func(v AttrType) bool {
			// date time is not supported in schema registry
			return false
		},
		"findIdKey": func(attrs map[string]AttrType) string {
			for k, v := range attrs {
				if v.Identifier {
					return k
				}
			}
			return "/* findIdKey: id not found */"
		},
	}

	fmt.Fprintf(res, "// Code generated by opus/essence/algebra/gm/gen.go. DO NOT EDIT.\n")
	fmt.Fprintf(res, "package %s\n\n", conf.PackageName)
	fmt.Fprintf(res, "import \"github.com/widmogrod/software-architecture-playground/opus/essence/algebra/kv\" \n")

	t := template.Must(template.New("go-default").Funcs(funMap).Parse(defaultStruct))
	err = t.Execute(res, sch)
	if err != nil {
		// wrap error with function name
		return fmt.Errorf("error generating golang code for %s: %w", id, err)
	}
	t = template.Must(template.New("go-struct").Funcs(funMap).Parse(goStruct))
	err = t.Execute(res, sch)
	if err != nil {
		// wrap error with function name
		return fmt.Errorf("error generating golang code for %s: %w", id, err)
	}

	t = template.Must(template.New("to-attributes").Funcs(funMap).Parse(toAttributes))
	err = t.Execute(res, sch)
	if err != nil {
		// wrap error with function name
		return fmt.Errorf("error generating golang code for %s: %w", id, err)
	}

	t = template.Must(template.New("to-key").Funcs(funMap).Parse(toKey))
	err = t.Execute(res, sch)
	if err != nil {
		// wrap error with function name
		return fmt.Errorf("error generating golang code for %s: %w", id, err)
	}
	t = template.Must(template.New("to-schema-id").Funcs(funMap).Parse(toSchemaId))
	err = t.Execute(res, sch)
	if err != nil {
		// wrap error with function name
		return fmt.Errorf("error generating golang code for %s: %w", id, err)
	}
	return nil
}
